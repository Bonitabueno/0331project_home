<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>몽자의 드림런</title>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #333;
            touch-action: none; -webkit-user-select: none; user-select: none;
        }
        canvas { display: block; margin: 0 auto; background-color: #f0f0f0; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }
        #score-board {
            position: absolute; top: 20px; left: 20px;
            font-size: 24px; font-weight: bold; color: #ff5e89;
            text-shadow: 2px 2px 0 #fff; font-family: sans-serif; display: none;
        }

        .popup-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; max-width: 320px; background: rgba(255, 255, 255, 0.95);
            padding: 30px 20px; border-radius: 20px; border: 5px solid #ff5e89;
            text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            pointer-events: auto; z-index: 20; display: flex; flex-direction: column; align-items: center;
        }

        h1 { font-size: 28px; color: #ff5e89; margin: 0 0 10px 0; }
        h2 { font-size: 24px; color: #ff5e89; margin: 0 0 10px 0; }
        p { font-size: 16px; color: #555; margin-bottom: 20px; line-height: 1.4; word-break: keep-all; }
        
        button {
            background: #ff5e89; color: white; border: none; padding: 15px 40px;
            font-size: 20px; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 4px 10px rgba(255, 94, 137, 0.4);
        }
        #game-over-screen { display: none; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="score-board">SCORE: <span id="score-val">0</span></div>
    </div>

    <div id="start-screen" class="popup-screen">
        <h1>몽자의 드림런</h1>
        <p>화면을 터치해서 점프!<br>디저트 나라를 달려봐요.</p>
        <button id="start-btn">게임 시작</button>
    </div>

    <div id="game-over-screen" class="popup-screen">
        <h2>꿈에서 깼어요!</h2>
        <p>최종 점수: <span id="final-score">0</span></p>
        <button id="restart-btn">다시 하기</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if(mongja) mongja.groundY = canvas.height - 150;
        });

        const mongjaImg = new Image();
        mongjaImg.src = './mongja.png';
        
        const bgImg = new Image();
        bgImg.src = './bg.png';

        // [핵심 수정] 배경 버퍼 캔버스 (거울모드 처리를 위해 미리 그려두는 곳)
        let bgPatternCanvas = document.createElement('canvas');
        let bgPatternCtx = bgPatternCanvas.getContext('2d');
        let bgReady = false;

        bgImg.onload = () => {
            // 배경 캔버스의 너비를 화면 너비의 2배로 설정 (원본 + 반전본)
            bgPatternCanvas.width = canvas.width * 2;
            bgPatternCanvas.height = canvas.height;

            // 1. 원본 그림 (왼쪽)
            bgPatternCtx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);

            // 2. 반전 그림 (오른쪽) - 여기가 거울 모드 핵심!
            bgPatternCtx.save();
            bgPatternCtx.scale(-1, 1); // 좌우 반전
            // 좌표계가 뒤집혔으므로 x좌표를 음수로 계산해서 넣어야 함
            bgPatternCtx.drawImage(bgImg, -canvas.width * 2, 0, canvas.width, canvas.height);
            bgPatternCtx.restore();

            bgReady = true;
        };

        let gameSpeed = 5;
        let score = 0;
        let isGameOver = false;
        let isPlaying = false;
        let animationId;

        const mongja = {
            x: screenWidth * 0.1, 
            y: screenHeight - 150,
            width: 80, height: 120, 
            dy: 0, jumpPower: -15, gravity: 0.7,
            groundY: screenHeight - 150,
            isJumping: false, jumpCount: 0, bobTimer: 0 
        };

        let obstacles = [];
        let frame = 0;

        function handleInput(e) {
            if (e.target.tagName === 'BUTTON') return;
            if (e.type === 'touchstart') e.preventDefault(); 
            if (!isPlaying || isGameOver) return;
            if (mongja.jumpCount < 2) {
                mongja.dy = mongja.jumpPower;
                mongja.isJumping = true;
                mongja.jumpCount++;
            }
        }

        window.addEventListener('touchstart', handleInput, { passive: false });
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('keydown', (e) => { if (e.code === 'Space') handleInput(e); });

        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('start-btn').addEventListener('touchstart', startGame);
        document.getElementById('restart-btn').addEventListener('click', resetGame);
        document.getElementById('restart-btn').addEventListener('touchstart', resetGame);

        function update() {
            if (!isPlaying || isGameOver) return;
            frame++;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // [배경 그리기 - 거울모드 적용된 버퍼 사용]
            if (bgReady) {
                // 전체 너비는 canvas.width * 2
                let totalWidth = canvas.width * 2;
                let bgX = -(frame * (gameSpeed * 0.5)) % totalWidth;

                // 2배 넓어진 이미지를 두 번 그려서 무한 스크롤 구현
                ctx.drawImage(bgPatternCanvas, bgX, 0);
                ctx.drawImage(bgPatternCanvas, bgX + totalWidth, 0);
            } else {
                ctx.fillStyle = "#FFEFF4";
                ctx.fillRect(0,0, canvas.width, canvas.height);
            }

            // [장애물]
            if (frame % 150 === 0) {
                let obsHeight = Math.random() * 60 + 50;
                obstacles.push({
                    x: canvas.width,
                    y: mongja.groundY + (80 - obsHeight),
                    width: 50, height: obsHeight, color: '#FFB6C1'
                });
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;
                ctx.fillStyle = obs.color;
                ctx.beginPath();
                ctx.roundRect(obs.x, obs.y, obs.width, obs.height, 10);
                ctx.fill();
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 3; ctx.stroke();

                if (mongja.x + 10 < obs.x + obs.width && mongja.x + mongja.width - 10 > obs.x &&
                    mongja.y + 10 < obs.y + obs.height && mongja.y + mongja.height - 10 > obs.y) {
                    gameOver();
                }
                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    score++;
                    document.getElementById('score-val').innerText = score;
                }
            }

            // [몽자]
            mongja.dy += mongja.gravity;
            mongja.y += mongja.dy;
            if (mongja.y > mongja.groundY) {
                mongja.y = mongja.groundY; mongja.dy = 0; mongja.isJumping = false; mongja.jumpCount = 0;
            }

            if (mongjaImg.complete && mongjaImg.naturalWidth !== 0) {
                let bobOffset = !mongja.isJumping ? Math.sin(mongja.bobTimer += 0.15) * 5 : (mongja.bobTimer = 0);
                ctx.drawImage(mongjaImg, mongja.x, mongja.y + bobOffset, mongja.width, mongja.height);
            } else {
                ctx.fillStyle = "#FF5E89";
                ctx.beginPath();
                ctx.roundRect(mongja.x, mongja.y, mongja.width, mongja.height, 10);
                ctx.fill();
            }

            animationId = requestAnimationFrame(update);
        }

        function init() {
            ctx.fillStyle = "#FFEFF4";
            ctx.fillRect(0,0, canvas.width, canvas.height);
            document.getElementById('start-screen').style.display = 'flex';
        }

        function startGame(e) { if(e) e.stopPropagation(); document.getElementById('start-screen').style.display = 'none'; document.getElementById('score-board').style.display = 'block'; resetValues(); isPlaying = true; update(); }
        function resetGame(e) { if(e) e.stopPropagation(); document.getElementById('game-over-screen').style.display = 'none'; resetValues(); isPlaying = true; update(); }
        function resetValues() { isGameOver = false; score = 0; frame = 0; obstacles = []; mongja.y = mongja.groundY; mongja.dy = 0; document.getElementById('score-val').innerText = 0; }
        function gameOver() { isGameOver = true; isPlaying = false; document.getElementById('game-over-screen').style.display = 'flex'; document.getElementById('final-score').innerText = score; cancelAnimationFrame(animationId); }

        init();
    </script>
</body>
</html>
